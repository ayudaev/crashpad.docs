<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Crashpad: crashpad::test Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Crashpad
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecrashpad.html">crashpad</a></li><li class="navelem"><a class="el" href="namespacecrashpad_1_1test.html">test</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">crashpad::test Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The testing namespace, for use in test code only.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1MachMultiprocess.html">MachMultiprocess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a Mach-aware multiprocess test.  <a href="classcrashpad_1_1test_1_1MachMultiprocess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrashpad_1_1test_1_1MinidumpWritableTraits.html">MinidumpWritableTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits class defining whether a minidump object type is required to appear only as a fixed-size object or if it is variable-sized.  <a href="structcrashpad_1_1test_1_1MinidumpWritableTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1Multiprocess.html">Multiprocess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a multiprocess test.  <a href="classcrashpad_1_1test_1_1Multiprocess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1MultiprocessExec.html">MultiprocessExec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages an <code>exec()</code>-based multiprocess test.  <a href="classcrashpad_1_1test_1_1MultiprocessExec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1Paths.html">Paths</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to obtain paths from within tests.  <a href="classcrashpad_1_1test_1_1Paths.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1ScopedTempDir.html">ScopedTempDir</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAII object that creates a temporary directory for testing.  <a href="classcrashpad_1_1test_1_1ScopedTempDir.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestExceptionSnapshot.html">TestExceptionSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ExceptionSnapshot.html" title="An abstract interface to a snapshot representing an exception that a snapshot process sustained and t...">ExceptionSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestExceptionSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestMemorySnapshot.html">TestMemorySnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1MemorySnapshot.html" title="An abstract interface to a snapshot representing a region of memory present in a snapshot process...">MemorySnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestMemorySnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html">TestMinidumpMemoryWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcrashpad_1_1MinidumpMemoryWriter.html" title="The base class for writers of memory ranges pointed to by MINIDUMP_MEMORY_DESCRIPTOR objects in a min...">MinidumpMemoryWriter</a> implementation used for testing.  <a href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestModuleSnapshot.html">TestModuleSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ModuleSnapshot.html" title="An abstract interface to a snapshot representing a code module (binary image) loaded into a snapshot ...">ModuleSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestModuleSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestProcessSnapshot.html">TestProcessSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ProcessSnapshot.html" title="An abstract interface to a snapshot representing the state of a process. ">ProcessSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestProcessSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestSystemSnapshot.html">TestSystemSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1SystemSnapshot.html" title="An abstract interface to a snapshot representing the state of a system, comprising an operating syste...">SystemSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestSystemSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestThreadSnapshot.html">TestThreadSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test <a class="el" href="classcrashpad_1_1ThreadSnapshot.html" title="An abstract interface to a snapshot representing a thread (lightweight process) present in a snapshot...">ThreadSnapshot</a> that can carry arbitrary data for testing purposes.  <a href="classcrashpad_1_1test_1_1TestThreadSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1TestUInt32MinidumpWritable.html">TestUInt32MinidumpWritable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classcrashpad_1_1internal_1_1MinidumpWritable.html" title="The base class for all content that might be written to a minidump file. ">internal::MinidumpWritable</a> that carries a <code>uint32_t</code> for testing.  <a href="classcrashpad_1_1test_1_1TestUInt32MinidumpWritable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1test_1_1Thread.html">Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic thread abstraction for testing. Users should derive from this class and implement ThreadMain().  <a href="classcrashpad_1_1test_1_1Thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a68bb97f184e9e5a41356a960fdaf3320"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a68bb97f184e9e5a41356a960fdaf3320">MinidumpHeaderAtStart</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__DIRECTORY.html">MINIDUMP_DIRECTORY</a> **directory)</td></tr>
<tr class="memdesc:a68bb97f184e9e5a41356a960fdaf3320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> at the start of a minidump file, along with the <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file. ">MINIDUMP_DIRECTORY</a> it references.  <a href="#a68bb97f184e9e5a41356a960fdaf3320">More...</a><br /></td></tr>
<tr class="separator:a68bb97f184e9e5a41356a960fdaf3320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e604ee6a23070a89e2a0015eb2854a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a5e604ee6a23070a89e2a0015eb2854a9">VerifyMinidumpHeader</a> (const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *header, uint32_t streams, uint32_t timestamp)</td></tr>
<tr class="memdesc:a5e604ee6a23070a89e2a0015eb2854a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> contains expected values.  <a href="#a5e604ee6a23070a89e2a0015eb2854a9">More...</a><br /></td></tr>
<tr class="separator:a5e604ee6a23070a89e2a0015eb2854a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d907f190db31282e6c8a08df38f7f3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a5d907f190db31282e6c8a08df38f7f3f">ExpectMinidumpMemoryDescriptor</a> (const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *expected, const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *observed)</td></tr>
<tr class="memdesc:a5d907f190db31282e6c8a08df38f7f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values.  <a href="#a5d907f190db31282e6c8a08df38f7f3f">More...</a><br /></td></tr>
<tr class="separator:a5d907f190db31282e6c8a08df38f7f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcb7b725b62a0058c18e0851a1adf5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a7bcb7b725b62a0058c18e0851a1adf5c">ExpectMinidumpMemoryDescriptorAndContents</a> (const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *expected, const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *observed, const std::string &amp;file_contents, uint8_t value, bool at_eof)</td></tr>
<tr class="memdesc:a7bcb7b725b62a0058c18e0851a1adf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values, and that the memory region it points to contains expected values assuming it was written by a <a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html" title="A MinidumpMemoryWriter implementation used for testing. ">TestMinidumpMemoryWriter</a> object.  <a href="#a7bcb7b725b62a0058c18e0851a1adf5c">More...</a><br /></td></tr>
<tr class="separator:a7bcb7b725b62a0058c18e0851a1adf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3936c22f43c2defcaa16e7c09ce544"><td class="memItemLeft" align="right" valign="top">const MinidumpRVAList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a1a3936c22f43c2defcaa16e7c09ce544">MinidumpRVAListAtStart</a> (const std::string &amp;file_contents, size_t count)</td></tr>
<tr class="memdesc:a1a3936c22f43c2defcaa16e7c09ce544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MinidumpRVAList at the start of a minidump file.  <a href="#a1a3936c22f43c2defcaa16e7c09ce544">More...</a><br /></td></tr>
<tr class="separator:a1a3936c22f43c2defcaa16e7c09ce544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527731a826e40dd36ac112e7cd3dfcd2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__STRING.html">MINIDUMP_STRING</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a527731a826e40dd36ac112e7cd3dfcd2">MinidumpStringAtRVA</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a527731a826e40dd36ac112e7cd3dfcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a> located within a minidump file’s contents.  <a href="#a527731a826e40dd36ac112e7cd3dfcd2">More...</a><br /></td></tr>
<tr class="separator:a527731a826e40dd36ac112e7cd3dfcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5bbb381b32ca4c5276a5aacbef1c5f"><td class="memItemLeft" align="right" valign="top">const MinidumpUTF8String *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a9f5bbb381b32ca4c5276a5aacbef1c5f">MinidumpUTF8StringAtRVA</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a9f5bbb381b32ca4c5276a5aacbef1c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a MinidumpUTF8String located within a minidump file’s contents.  <a href="#a9f5bbb381b32ca4c5276a5aacbef1c5f">More...</a><br /></td></tr>
<tr class="separator:a9f5bbb381b32ca4c5276a5aacbef1c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2276ff84807d40b2fc4f7fd2ccc8b743"><td class="memItemLeft" align="right" valign="top">base::string16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a2276ff84807d40b2fc4f7fd2ccc8b743">MinidumpStringAtRVAAsString</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a2276ff84807d40b2fc4f7fd2ccc8b743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a> as a <code>string16</code>.  <a href="#a2276ff84807d40b2fc4f7fd2ccc8b743">More...</a><br /></td></tr>
<tr class="separator:a2276ff84807d40b2fc4f7fd2ccc8b743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8f1de3f021881b6464a1fedbddf956"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a4d8f1de3f021881b6464a1fedbddf956">MinidumpUTF8StringAtRVAAsString</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a4d8f1de3f021881b6464a1fedbddf956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of a MinidumpUTF8String as a <code>std::string</code>.  <a href="#a4d8f1de3f021881b6464a1fedbddf956">More...</a><br /></td></tr>
<tr class="separator:a4d8f1de3f021881b6464a1fedbddf956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbb750966dcd4d580ba9eeb51a45fc6"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a5cbb750966dcd4d580ba9eeb51a45fc6">MinidumpWritableAtLocationDescriptorInternal</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location, size_t expected_size, bool allow_oversized_data)</td></tr>
<tr class="memdesc:a5cbb750966dcd4d580ba9eeb51a45fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an untyped minidump object located within a minidump file’s contents, where the offset and size of the object are known.  <a href="#a5cbb750966dcd4d580ba9eeb51a45fc6">More...</a><br /></td></tr>
<tr class="separator:a5cbb750966dcd4d580ba9eeb51a45fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memTemplParams" colspan="2"><a class="anchor" id="acbef5521fa7d72b22f11af5fb6c46c8b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structIMAGE__DEBUG__MISC.html">IMAGE_DEBUG_MISC</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; IMAGE_DEBUG_MISC &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:acbef5521fa7d72b22f11af5fb6c46c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3cfd6e9d9034ac4eb0fa4a81d5d24f47"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_HEADER &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a3cfd6e9d9034ac4eb0fa4a81d5d24f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01134f431c0e023b0c28b1b11884d0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="af01134f431c0e023b0c28b1b11884d0e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af01134f431c0e023b0c28b1b11884d0e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__MEMORY__LIST.html">MINIDUMP_MEMORY_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_MEMORY_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:af01134f431c0e023b0c28b1b11884d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2e4fb44a0fd839f5c5741163cf55e5c4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__MODULE__LIST.html">MINIDUMP_MODULE_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_MODULE_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a2e4fb44a0fd839f5c5741163cf55e5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ac3245d9630d709dda9d852bbb3594"><td class="memTemplParams" colspan="2"><a class="anchor" id="af5ac3245d9630d709dda9d852bbb3594"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af5ac3245d9630d709dda9d852bbb3594"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structMINIDUMP__THREAD__LIST.html">MINIDUMP_THREAD_LIST</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MINIDUMP_THREAD_LIST &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:af5ac3245d9630d709dda9d852bbb3594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ca9502c6765e74527d0a890588aabf"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1ca9502c6765e74527d0a890588aabf"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae1ca9502c6765e74527d0a890588aabf"><td class="memTemplItemLeft" align="right" valign="top">const MinidumpModuleCrashpadInfoList *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpModuleCrashpadInfoList &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:ae1ca9502c6765e74527d0a890588aabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69ddf4143c3bf004ae589fd7566f88"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7e69ddf4143c3bf004ae589fd7566f88"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7e69ddf4143c3bf004ae589fd7566f88"><td class="memTemplItemLeft" align="right" valign="top">const MinidumpSimpleStringDictionary *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpSimpleStringDictionary &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a7e69ddf4143c3bf004ae589fd7566f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918659386362c8450a4ab8d22063d186"><td class="memTemplParams" colspan="2"><a class="anchor" id="a918659386362c8450a4ab8d22063d186"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a918659386362c8450a4ab8d22063d186"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpModuleCodeViewRecordPDB20.html">MinidumpModuleCodeViewRecordPDB20</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpModuleCodeViewRecordPDB20 &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a918659386362c8450a4ab8d22063d186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d70ceaa8c62a51b18ce32db080bd8ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7d70ceaa8c62a51b18ce32db080bd8ff"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7d70ceaa8c62a51b18ce32db080bd8ff"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structcrashpad_1_1MinidumpModuleCodeViewRecordPDB70.html">MinidumpModuleCodeViewRecordPDB70</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinidumpWritableAtLocationDescriptor&lt; MinidumpModuleCodeViewRecordPDB70 &gt;</b> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="separator:a7d70ceaa8c62a51b18ce32db080bd8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74140dac921a98cd307aa9935e3d114b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74140dac921a98cd307aa9935e3d114b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__DIRECTORY.html">MINIDUMP_DIRECTORY</a>)</td></tr>
<tr class="separator:a74140dac921a98cd307aa9935e3d114b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d55335cfc826aa10bcca7e5bafbe9d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d55335cfc826aa10bcca7e5bafbe9d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__MEMORY__LIST.html">MINIDUMP_MEMORY_LIST</a>)</td></tr>
<tr class="separator:a4d55335cfc826aa10bcca7e5bafbe9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d1f4c122b7e84f7a7cc47631689fd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90d1f4c122b7e84f7a7cc47631689fd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__MODULE__LIST.html">MINIDUMP_MODULE_LIST</a>)</td></tr>
<tr class="separator:a90d1f4c122b7e84f7a7cc47631689fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b5b9ccf411a827569d2ef7705203a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62b5b9ccf411a827569d2ef7705203a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__THREAD__LIST.html">MINIDUMP_THREAD_LIST</a>)</td></tr>
<tr class="separator:a62b5b9ccf411a827569d2ef7705203a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1a5769138fd33b721795773deea6ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b1a5769138fd33b721795773deea6ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (MinidumpModuleCrashpadInfoList)</td></tr>
<tr class="separator:a7b1a5769138fd33b721795773deea6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615edb0cc10ae7de6b93d020cf0bfaf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a615edb0cc10ae7de6b93d020cf0bfaf4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (MinidumpRVAList)</td></tr>
<tr class="separator:a615edb0cc10ae7de6b93d020cf0bfaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302566ec2aa6e6771db3b4be4e6aa682"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a302566ec2aa6e6771db3b4be4e6aa682"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (MinidumpSimpleStringDictionary)</td></tr>
<tr class="separator:a302566ec2aa6e6771db3b4be4e6aa682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e90afb7c78eafed9eda8485265ae16a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e90afb7c78eafed9eda8485265ae16a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structIMAGE__DEBUG__MISC.html">IMAGE_DEBUG_MISC</a>)</td></tr>
<tr class="separator:a2e90afb7c78eafed9eda8485265ae16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690a621b0359475ed37034c4e75f26b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a690a621b0359475ed37034c4e75f26b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structMINIDUMP__STRING.html">MINIDUMP_STRING</a>)</td></tr>
<tr class="separator:a690a621b0359475ed37034c4e75f26b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1149557d0e628799f0fb07a464157644"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1149557d0e628799f0fb07a464157644"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1MinidumpModuleCodeViewRecordPDB20.html">MinidumpModuleCodeViewRecordPDB20</a>)</td></tr>
<tr class="separator:a1149557d0e628799f0fb07a464157644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5322fcacbbb1119aa2ce5476bdae339"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5322fcacbbb1119aa2ce5476bdae339"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (<a class="el" href="structcrashpad_1_1MinidumpModuleCodeViewRecordPDB70.html">MinidumpModuleCodeViewRecordPDB70</a>)</td></tr>
<tr class="separator:ad5322fcacbbb1119aa2ce5476bdae339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61f5e906dff25a41c015dbcf02a8cff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af61f5e906dff25a41c015dbcf02a8cff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (MinidumpUTF8String)</td></tr>
<tr class="separator:af61f5e906dff25a41c015dbcf02a8cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4ed41a7f2c94d294e1c1bca34a3e15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b4ed41a7f2c94d294e1c1bca34a3e15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MINIDUMP_ALLOW_OVERSIZED_DATA</b> (uint8_t)</td></tr>
<tr class="separator:a7b4ed41a7f2c94d294e1c1bca34a3e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda65d4c6e9c710f32fcbd9af6a03357"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abda65d4c6e9c710f32fcbd9af6a03357"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#abda65d4c6e9c710f32fcbd9af6a03357">TMinidumpWritableAtLocationDescriptor</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="memdesc:abda65d4c6e9c710f32fcbd9af6a03357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known.  <a href="#abda65d4c6e9c710f32fcbd9af6a03357">More...</a><br /></td></tr>
<tr class="separator:abda65d4c6e9c710f32fcbd9af6a03357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e98915fad73c8628924c3a900732fc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e98915fad73c8628924c3a900732fc0"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a0e98915fad73c8628924c3a900732fc0">MinidumpWritableAtLocationDescriptor</a> (const std::string &amp;file_contents, const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;location)</td></tr>
<tr class="memdesc:a0e98915fad73c8628924c3a900732fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known.  <a href="#a0e98915fad73c8628924c3a900732fc0">More...</a><br /></td></tr>
<tr class="separator:a0e98915fad73c8628924c3a900732fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3e635fd21c8c642d41ceb2072e7d08"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b3e635fd21c8c642d41ceb2072e7d08"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a5b3e635fd21c8c642d41ceb2072e7d08">MinidumpWritableAtRVA</a> (const std::string &amp;file_contents, <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a> rva)</td></tr>
<tr class="memdesc:a5b3e635fd21c8c642d41ceb2072e7d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typed minidump object located within a minidump file’s contents, where the offset of the object is known.  <a href="#a5b3e635fd21c8c642d41ceb2072e7d08">More...</a><br /></td></tr>
<tr class="separator:a5b3e635fd21c8c642d41ceb2072e7d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35412b33d0a275fa43e8633296059534"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a35412b33d0a275fa43e8633296059534">ReadStreamToString</a> (<a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *stream)</td></tr>
<tr class="memdesc:a35412b33d0a275fa43e8633296059534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body. ">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string.  <a href="#a35412b33d0a275fa43e8633296059534">More...</a><br /></td></tr>
<tr class="separator:a35412b33d0a275fa43e8633296059534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861ba97c72a60c7e1802c39395d1d1fe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a861ba97c72a60c7e1802c39395d1d1fe">ReadStreamToString</a> (<a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *stream, size_t buffer_size)</td></tr>
<tr class="memdesc:a861ba97c72a60c7e1802c39395d1d1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body. ">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string.  <a href="#a861ba97c72a60c7e1802c39395d1d1fe">More...</a><br /></td></tr>
<tr class="separator:a861ba97c72a60c7e1802c39395d1d1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9504862c089964763d7d362572c2ac6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#ad9504862c089964763d7d362572c2ac6">ErrnoMessage</a> (int err, const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:ad9504862c089964763d7d362572c2ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message using an <code>errno</code> value.  <a href="#ad9504862c089964763d7d362572c2ac6">More...</a><br /></td></tr>
<tr class="separator:ad9504862c089964763d7d362572c2ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8e66fbc47a4f22a03710797f226238"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a8d8e66fbc47a4f22a03710797f226238">ErrnoMessage</a> (const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:a8d8e66fbc47a4f22a03710797f226238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message using <code>errno</code>.  <a href="#a8d8e66fbc47a4f22a03710797f226238">More...</a><br /></td></tr>
<tr class="separator:a8d8e66fbc47a4f22a03710797f226238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d079e80aa56bc0840f1c0b944e01bfb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a2d079e80aa56bc0840f1c0b944e01bfb">ErrorMessage</a> (const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:a2d079e80aa56bc0840f1c0b944e01bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an error message using <code>GetLastError()</code>.  <a href="#a2d079e80aa56bc0840f1c0b944e01bfb">More...</a><br /></td></tr>
<tr class="separator:a2d079e80aa56bc0840f1c0b944e01bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a7a2461cf4e1f674eac147c19d9483"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a49a7a2461cf4e1f674eac147c19d9483">MachErrorMessage</a> (mach_error_t mach_err, const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:a49a7a2461cf4e1f674eac147c19d9483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a Mach error message.  <a href="#a49a7a2461cf4e1f674eac147c19d9483">More...</a><br /></td></tr>
<tr class="separator:a49a7a2461cf4e1f674eac147c19d9483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db2fa97998b00a8ee57398fa8c8b14e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a8db2fa97998b00a8ee57398fa8c8b14e">BootstrapErrorMessage</a> (kern_return_t bootstrap_err, const std::string &amp;base=std::string())</td></tr>
<tr class="memdesc:a8db2fa97998b00a8ee57398fa8c8b14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a bootstrap error message.  <a href="#a8db2fa97998b00a8ee57398fa8c8b14e">More...</a><br /></td></tr>
<tr class="separator:a8db2fa97998b00a8ee57398fa8c8b14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afefac1494b6a67c50a254c75a8caccf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#afefac1494b6a67c50a254c75a8caccf1">InitializeMinidumpContextX86</a> (<a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:afefac1494b6a67c50a254c75a8caccf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <a href="#afefac1494b6a67c50a254c75a8caccf1">More...</a><br /></td></tr>
<tr class="separator:afefac1494b6a67c50a254c75a8caccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1dd7166c73ca082608b1ab21b5a395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#afa1dd7166c73ca082608b1ab21b5a395">InitializeMinidumpContextAMD64</a> (MinidumpContextAMD64 *context, uint32_t seed)</td></tr>
<tr class="memdesc:afa1dd7166c73ca082608b1ab21b5a395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <a href="#afa1dd7166c73ca082608b1ab21b5a395">More...</a><br /></td></tr>
<tr class="separator:afa1dd7166c73ca082608b1ab21b5a395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a774c6adc6455eb01f0595262c1ce7df9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a774c6adc6455eb01f0595262c1ce7df9">ExpectMinidumpContextX86</a> (uint32_t expect_seed, const <a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *observed, bool snapshot)</td></tr>
<tr class="memdesc:a774c6adc6455eb01f0595262c1ce7df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via gtest assertions, that a context structure contains expected values.  <a href="#a774c6adc6455eb01f0595262c1ce7df9">More...</a><br /></td></tr>
<tr class="separator:a774c6adc6455eb01f0595262c1ce7df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b85697010c624299be8ac6192cc3ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#ac5b85697010c624299be8ac6192cc3ed">ExpectMinidumpContextAMD64</a> (uint32_t expect_seed, const MinidumpContextAMD64 *observed, bool snapshot)</td></tr>
<tr class="memdesc:ac5b85697010c624299be8ac6192cc3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies, via gtest assertions, that a context structure contains expected values.  <a href="#ac5b85697010c624299be8ac6192cc3ed">More...</a><br /></td></tr>
<tr class="separator:ac5b85697010c624299be8ac6192cc3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adfb5c0e6e1c121bdac4c663a3fa0db06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#adfb5c0e6e1c121bdac4c663a3fa0db06">InitializeCPUContextX86</a> (<a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:adfb5c0e6e1c121bdac4c663a3fa0db06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <a href="#adfb5c0e6e1c121bdac4c663a3fa0db06">More...</a><br /></td></tr>
<tr class="separator:adfb5c0e6e1c121bdac4c663a3fa0db06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea06b36ac8ee94add2d8aaca404265c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a9ea06b36ac8ee94add2d8aaca404265c">InitializeCPUContextX86_64</a> (<a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *context, uint32_t seed)</td></tr>
<tr class="memdesc:a9ea06b36ac8ee94add2d8aaca404265c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a context structure for testing.  <a href="#a9ea06b36ac8ee94add2d8aaca404265c">More...</a><br /></td></tr>
<tr class="separator:a9ea06b36ac8ee94add2d8aaca404265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a623baebebe1cf76d4ddcd1ba30116587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a623baebebe1cf76d4ddcd1ba30116587">InitializeCPUContextX86Fxsave</a> (<a class="el" href="structcrashpad_1_1CPUContextX86_1_1Fxsave.html">CPUContextX86::Fxsave</a> *fxsave, uint32_t *seed)</td></tr>
<tr class="memdesc:a623baebebe1cf76d4ddcd1ba30116587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an <code>fxsave</code> context substructure for testing.  <a href="#a623baebebe1cf76d4ddcd1ba30116587">More...</a><br /></td></tr>
<tr class="separator:a623baebebe1cf76d4ddcd1ba30116587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d029ec1724e63a58007a8705975df23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrashpad_1_1test.html#a5d029ec1724e63a58007a8705975df23">InitializeCPUContextX86_64Fxsave</a> (<a class="el" href="structcrashpad_1_1CPUContextX86__64_1_1Fxsave.html">CPUContextX86_64::Fxsave</a> *fxsave, uint32_t *seed)</td></tr>
<tr class="memdesc:a5d029ec1724e63a58007a8705975df23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an <code>fxsave</code> context substructure for testing.  <a href="#a5d029ec1724e63a58007a8705975df23">More...</a><br /></td></tr>
<tr class="separator:a5d029ec1724e63a58007a8705975df23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The testing namespace, for use in test code only. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8db2fa97998b00a8ee57398fa8c8b14e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::BootstrapErrorMessage </td>
          <td>(</td>
          <td class="paramtype">kern_return_t&#160;</td>
          <td class="paramname"><em>bootstrap_err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a bootstrap error message. </p>
<p>The returned string will combine the <em>base</em> string, if supplied, with a a textual and numeric description of the error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bootstrap_err</td><td>The bootstrap error code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>A string to prepend to the error description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the format <code>"Permission denied (1100)"</code> if <em>bootstrap_err</em> has the value <code>BOOTSTRAP_NOT_PRIVILEGED</code> on a system where this is defined to be 1100. If <em>base</em> is not empty, it will be prepended to this string, separated by a colon. If <em>bootstrap_err</em> is not a valid bootstrap error code, it will be interpreted as a Mach error code in the manner of <a class="el" href="namespacecrashpad_1_1test.html#a49a7a2461cf4e1f674eac147c19d9483" title="Formats a Mach error message. ">MachErrorMessage()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9504862c089964763d7d362572c2ac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ErrnoMessage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats an error message using an <code>errno</code> value. </p>
<p>The returned string will combine the <em>base</em> string, if supplied, with a a textual and numeric description of the error.</p>
<p>The message is formatted using <code>strerror()</code>. <em>err</em> may be <code>0</code> or outside of the range of known error codes, and the message returned will contain the string that <code>strerror()</code> uses in these cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>The error code, usable as an <code>errno</code> value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>A string to prepend to the error description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the format <code>"Operation not permitted (1)"</code> if <em>err</em> has the value <code>EPERM</code> on a system where this is defined to be <code>1</code>. If <em>base</em> is not empty, it will be prepended to this string, separated by a colon. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d8e66fbc47a4f22a03710797f226238"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ErrnoMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>std::string()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats an error message using <code>errno</code>. </p>
<p>The returned string will combine the <em>base</em> string, if supplied, with a a textual and numeric description of the error.</p>
<p>The message is formatted using <code>strerror()</code>. <code>errno</code> may be <code>0</code> or outside of the range of known error codes, and the message returned will contain the string that <code>strerror()</code> uses in these cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>A string to prepend to the error description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the format <code>"Operation not permitted (1)"</code> if <code>errno</code> has the value <code>EPERM</code> on a system where this is defined to be <code>1</code>. If <em>base</em> is not empty, it will be prepended to this string, separated by a colon. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d079e80aa56bc0840f1c0b944e01bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ErrorMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>std::string()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats an error message using <code>GetLastError()</code>. </p>
<p>The returned string will combine the <em>base</em> string, if supplied, with a a textual and numeric description of the error. The format is the same as the <code>PLOG()</code> formatting in base. </p>

</div>
</div>
<a class="anchor" id="ac5b85697010c624299be8ac6192cc3ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpContextAMD64 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expect_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MinidumpContextAMD64 *&#160;</td>
          <td class="paramname"><em>observed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snapshot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via gtest assertions, that a context structure contains expected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expect_seed</td><td>The seed value used to initialize a context structure. This is the seed value used with InitializeMinidumpContext*(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>The context structure to check. All fields of this structure will be compared against the expected context structure, one initialized with <em>expect_seed</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot</td><td>If <code>true</code>, compare <em>observed</em> to a context structure expected to be produced from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> snapshot. If <code>false</code>, compare <em>observed</em> to a native minidump context structure. <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> snapshot structures may carry different sets of data than native minidump context structures in meaningless ways. When <code>true</code>, fields not found in <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> structures are expected to be <code>0</code>. When <code>false</code>, all fields are compared. This makes it possible to test both that these fields are passed through correctly by the native minidump writer and are zeroed out when creating a minidump context structure from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a774c6adc6455eb01f0595262c1ce7df9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpContextX86 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expect_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *&#160;</td>
          <td class="paramname"><em>observed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snapshot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via gtest assertions, that a context structure contains expected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expect_seed</td><td>The seed value used to initialize a context structure. This is the seed value used with InitializeMinidumpContext*(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>The context structure to check. All fields of this structure will be compared against the expected context structure, one initialized with <em>expect_seed</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snapshot</td><td>If <code>true</code>, compare <em>observed</em> to a context structure expected to be produced from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> snapshot. If <code>false</code>, compare <em>observed</em> to a native minidump context structure. <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> snapshot structures may carry different sets of data than native minidump context structures in meaningless ways. When <code>true</code>, fields not found in <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> structures are expected to be <code>0</code>. When <code>false</code>, all fields are compared. This makes it possible to test both that these fields are passed through correctly by the native minidump writer and are zeroed out when creating a minidump context structure from a <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d907f190db31282e6c8a08df38f7f3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpMemoryDescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *&#160;</td>
          <td class="paramname"><em>observed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values. </p>
<p>In <em>expected</em> and <em>observed</em>, <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html#ac6d589aa4a3b82315866f2a27bee770c" title="The base address of the memory region in the address space of the process that the minidump file cont...">MINIDUMP_MEMORY_DESCRIPTOR::StartOfMemoryRange</a> and <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html#ad83430521d4a8991d85e06be61525a92" title="The size of the referenced structure or union, in bytes. ">MINIDUMP_LOCATION_DESCRIPTOR::DataSize</a> are compared and must match. If <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html#ae877992492577366d7185721b8239877" title="The relative virtual address of the structure or union within the minidump file. ">MINIDUMP_LOCATION_DESCRIPTOR::Rva</a> is nonzero in <em>expected</em>, the same field in <em>observed</em> must match it, subject to a 16-byte alignment augmentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expected</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing expected values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing observed values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bcb7b725b62a0058c18e0851a1adf5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::ExpectMinidumpMemoryDescriptorAndContents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html">MINIDUMP_MEMORY_DESCRIPTOR</a> *&#160;</td>
          <td class="paramname"><em>observed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>at_eof</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure contains expected values, and that the memory region it points to contains expected values assuming it was written by a <a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html" title="A MinidumpMemoryWriter implementation used for testing. ">TestMinidumpMemoryWriter</a> object. </p>
<p><em>expected</em> and <em>observed</em> are compared by <a class="el" href="namespacecrashpad_1_1test.html#a5d907f190db31282e6c8a08df38f7f3f" title="Verifies, via gtest assertions, that a MINIDUMP_MEMORY_DESCRIPTOR structure contains expected values...">ExpectMinidumpMemoryDescriptor()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expected</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing expected values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observed</td><td>A <a class="el" href="structMINIDUMP__MEMORY__DESCRIPTOR.html" title="A pointer to a snapshot of a region of memory contained within a minidump file. ">MINIDUMP_MEMORY_DESCRIPTOR</a> structure containing observed values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file in which <em>observed</em> was found. The memory region referenced by <em>observed</em> will be read from this string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The <em>value</em> used to create a <a class="el" href="classcrashpad_1_1test_1_1TestMinidumpMemoryWriter.html" title="A MinidumpMemoryWriter implementation used for testing. ">TestMinidumpMemoryWriter</a>. Each byte of memory in the region referenced by <em>observed</em> must be this value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">at_eof</td><td>If <code>true</code>, the region referenced by <em>observed</em> must appear at the end of <em>file_contents</em>, without any data following it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfb5c0e6e1c121bdac4c663a3fa0db06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by minidump context test initialization functions such as <a class="el" href="namespacecrashpad_1_1test.html#afefac1494b6a67c50a254c75a8caccf1" title="Initializes a context structure for testing. ">InitializeMinidumpContextX86()</a> and <a class="el" href="namespacecrashpad_1_1test.html#afa1dd7166c73ca082608b1ab21b5a395" title="Initializes a context structure for testing. ">InitializeMinidumpContextAMD64()</a> for identical <em>seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em>seed</em> is <code>0</code>, <em>context</em> is zeroed out entirely except for the <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union...">CPUContext::architecture</a> field, which will identify the context type. If <em>seed</em> is nonzero, <em>context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ea06b36ac8ee94add2d8aaca404265c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContext.html">CPUContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by minidump context test initialization functions such as <a class="el" href="namespacecrashpad_1_1test.html#afefac1494b6a67c50a254c75a8caccf1" title="Initializes a context structure for testing. ">InitializeMinidumpContextX86()</a> and <a class="el" href="namespacecrashpad_1_1test.html#afa1dd7166c73ca082608b1ab21b5a395" title="Initializes a context structure for testing. ">InitializeMinidumpContextAMD64()</a> for identical <em>seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em>seed</em> is <code>0</code>, <em>context</em> is zeroed out entirely except for the <a class="el" href="structcrashpad_1_1CPUContext.html#af71f7a2e8478339d53fcb9d52ded6ae5" title="The CPU architecture of a context structure. This field controls the expression of the union...">CPUContext::architecture</a> field, which will identify the context type. If <em>seed</em> is nonzero, <em>context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d029ec1724e63a58007a8705975df23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86_64Fxsave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContextX86__64_1_1Fxsave.html">CPUContextX86_64::Fxsave</a> *&#160;</td>
          <td class="paramname"><em>fxsave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an <code>fxsave</code> context substructure for testing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fxsave</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">seed</td><td>The seed value. Initializing two <code>fxsave</code> structures of the same type with identical seed values should produce identical structures. Initialization with a different seed value should produce a different <code>fxsave</code> structure. If <em>seed</em> is <code>0</code>, <em>fxsave</em> is zeroed out entirely. If <em>seed</em> is nonzero, <em>fxsave</em> will be populated entirely with nonzero values. <em>seed</em> will be updated by this function to allow the caller to perform subsequent initialization of the context structure containing <em>fxsave</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a623baebebe1cf76d4ddcd1ba30116587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeCPUContextX86Fxsave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1CPUContextX86_1_1Fxsave.html">CPUContextX86::Fxsave</a> *&#160;</td>
          <td class="paramname"><em>fxsave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an <code>fxsave</code> context substructure for testing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fxsave</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">seed</td><td>The seed value. Initializing two <code>fxsave</code> structures of the same type with identical seed values should produce identical structures. Initialization with a different seed value should produce a different <code>fxsave</code> structure. If <em>seed</em> is <code>0</code>, <em>fxsave</em> is zeroed out entirely. If <em>seed</em> is nonzero, <em>fxsave</em> will be populated entirely with nonzero values. <em>seed</em> will be updated by this function to allow the caller to perform subsequent initialization of the context structure containing <em>fxsave</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa1dd7166c73ca082608b1ab21b5a395"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMinidumpContextAMD64 </td>
          <td>(</td>
          <td class="paramtype">MinidumpContextAMD64 *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> test initialization functions such as <a class="el" href="namespacecrashpad_1_1test.html#adfb5c0e6e1c121bdac4c663a3fa0db06" title="Initializes a context structure for testing. ">InitializeCPUContextX86()</a> and <a class="el" href="namespacecrashpad_1_1test.html#a9ea06b36ac8ee94add2d8aaca404265c" title="Initializes a context structure for testing. ">InitializeCPUContextX86_64()</a> for identical <em>seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em>seed</em> is <code>0</code>, <em>context</em> is zeroed out entirely except for the flags field, which will identify the context type. If <em>seed</em> is nonzero, <em>context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afefac1494b6a67c50a254c75a8caccf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::InitializeMinidumpContextX86 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrashpad_1_1MinidumpContextX86.html">MinidumpContextX86</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a context structure for testing. </p>
<p>Initialization is compatible with the initialization used by <a class="el" href="structcrashpad_1_1CPUContext.html" title="A context structure capable of carrying the context of any supported CPU architecture. ">CPUContext</a> test initialization functions such as <a class="el" href="namespacecrashpad_1_1test.html#adfb5c0e6e1c121bdac4c663a3fa0db06" title="Initializes a context structure for testing. ">InitializeCPUContextX86()</a> and <a class="el" href="namespacecrashpad_1_1test.html#a9ea06b36ac8ee94add2d8aaca404265c" title="Initializes a context structure for testing. ">InitializeCPUContextX86_64()</a> for identical <em>seed</em> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>The structure to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>The seed value. Initializing two context structures of the same type with identical seed values should produce identical context structures. Initialization with a different seed value should produce a different context structure. If <em>seed</em> is <code>0</code>, <em>context</em> is zeroed out entirely except for the flags field, which will identify the context type. If <em>seed</em> is nonzero, <em>context</em> will be populated entirely with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49a7a2461cf4e1f674eac147c19d9483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::MachErrorMessage </td>
          <td>(</td>
          <td class="paramtype">mach_error_t&#160;</td>
          <td class="paramname"><em>mach_err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a Mach error message. </p>
<p>The returned string will combine the <em>base</em> string, if supplied, with a a textual and numeric description of the error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mach_err</td><td>The Mach error code, which may be a <code>kern_return_t</code> or related type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>A string to prepend to the error description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of the format <code>"(os/kern) invalid address (1)"</code> if <em>mach_err</em> has the value <code>KERN_INVALID_ADDRESS</code> on a system where this is defined to be 1. If <em>base</em> is not empty, it will be prepended to this string, separated by a colon. </dd></dl>

</div>
</div>
<a class="anchor" id="a68bb97f184e9e5a41356a960fdaf3320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> * crashpad::test::MinidumpHeaderAtStart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__DIRECTORY.html">MINIDUMP_DIRECTORY</a> **&#160;</td>
          <td class="paramname"><em>directory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> at the start of a minidump file, along with the <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file. ">MINIDUMP_DIRECTORY</a> it references. </p>
<p>This function validates the <a class="el" href="structMINIDUMP__HEADER.html#ae1c77644aa56ab70fd6f50c343eafda8" title="The minidump file format magic number, MINIDUMP_SIGNATURE. ">MINIDUMP_HEADER::Signature</a> and <a class="el" href="structMINIDUMP__HEADER.html#a7ea8d51f5ca990eec9eb0b3643c6b406" title="The minidump file format version number, MINIDUMP_VERSION. ">MINIDUMP_HEADER::Version</a> fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">directory</td><td>The <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file. ">MINIDUMP_DIRECTORY</a> referenced by the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a>. If the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> does not reference a <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file. ">MINIDUMP_DIRECTORY</a>, <code>nullptr</code> without raising a gtest assertion. If the referenced <a class="el" href="structMINIDUMP__DIRECTORY.html" title="A pointer to a stream within a minidump file. ">MINIDUMP_DIRECTORY</a> is not valid, <code>nullptr</code> with a gtest assertion raised. On failure, <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> at the beginning of the minidump file. On failure, raises a gtest assertion and returns <code>nullptr</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a3936c22f43c2defcaa16e7c09ce544"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const MinidumpRVAList * crashpad::test::MinidumpRVAListAtStart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MinidumpRVAList at the start of a minidump file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of <a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8" title="An offset within a minidump file, relative to the start of its MINIDUMP_HEADER. ">RVA</a> objects expected in the MinidumpRVAList. This function will only be successful if exactly this many objects are present, and if space for them exists in <em>file_contents</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the MinidumpRVAList at the beginning of the file. On failure, raises a gtest assertion and returns <code>nullptr</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a527731a826e40dd36ac112e7cd3dfcd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMINIDUMP__STRING.html">MINIDUMP_STRING</a> * crashpad::test::MinidumpStringAtRVA </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a>&#160;</td>
          <td class="paramname"><em>rva</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a> located within a minidump file’s contents. </p>
<p>If <em>rva</em> points outside of the range of <em>file_contents</em>, if the string has an incorrect length or is not <code>NUL</code>-terminated, or if any of the string data would lie outside of the range of <em>file_contents</em>, this function will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a> in <em>file_contents</em>. On failure, raises a gtest assertion and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a2276ff84807d40b2fc4f7fd2ccc8b743" title="Returns the contents of a MINIDUMP_STRING as a string16. ">MinidumpStringAtRVAAsString()</a> </dd>
<dd>
<a class="el" href="namespacecrashpad_1_1test.html#a9f5bbb381b32ca4c5276a5aacbef1c5f" title="Returns a MinidumpUTF8String located within a minidump file’s contents. ">MinidumpUTF8StringAtRVA()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2276ff84807d40b2fc4f7fd2ccc8b743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">base::string16 crashpad::test::MinidumpStringAtRVAAsString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a>&#160;</td>
          <td class="paramname"><em>rva</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a> as a <code>string16</code>. </p>
<p>This function uses <a class="el" href="namespacecrashpad_1_1test.html#a527731a826e40dd36ac112e7cd3dfcd2" title="Returns a MINIDUMP_STRING located within a minidump file’s contents. ">MinidumpStringAtRVA()</a> to obtain a <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a>, and returns the string data as a <code>string16</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired <a class="el" href="structMINIDUMP__STRING.html" title="A variable-length UTF-16-encoded string carried within a minidump file. ">MINIDUMP_STRING</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the string read from <em>file_writer</em> at offset <em>rva</em>. On failure, raises a gtest assertion and returns an empty string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a4d8f1de3f021881b6464a1fedbddf956" title="Returns the contents of a MinidumpUTF8String as a std::string. ">MinidumpUTF8StringAtRVAAsString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9f5bbb381b32ca4c5276a5aacbef1c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const MinidumpUTF8String * crashpad::test::MinidumpUTF8StringAtRVA </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a>&#160;</td>
          <td class="paramname"><em>rva</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a MinidumpUTF8String located within a minidump file’s contents. </p>
<p>If <em>rva</em> points outside of the range of <em>file_contents</em>, if the string has an incorrect length or is not <code>NUL</code>-terminated, or if any of the string data would lie outside of the range of <em>file_contents</em>, this function will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired MinidumpUTF8String.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the MinidumpUTF8String in <em>file_contents</em>. On failure, raises a gtest assertion and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a4d8f1de3f021881b6464a1fedbddf956" title="Returns the contents of a MinidumpUTF8String as a std::string. ">MinidumpUTF8StringAtRVAAsString()</a> </dd>
<dd>
<a class="el" href="namespacecrashpad_1_1test.html#a527731a826e40dd36ac112e7cd3dfcd2" title="Returns a MINIDUMP_STRING located within a minidump file’s contents. ">MinidumpStringAtRVA()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4d8f1de3f021881b6464a1fedbddf956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::MinidumpUTF8StringAtRVAAsString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a>&#160;</td>
          <td class="paramname"><em>rva</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of a MinidumpUTF8String as a <code>std::string</code>. </p>
<p>This function uses <a class="el" href="namespacecrashpad_1_1test.html#a9f5bbb381b32ca4c5276a5aacbef1c5f" title="Returns a MinidumpUTF8String located within a minidump file’s contents. ">MinidumpUTF8StringAtRVA()</a> to obtain a MinidumpUTF8String, and returns the string data as a <code>std::string</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired MinidumpUTF8String.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the string read from <em>file_writer</em> at offset <em>rva</em>. On failure, raises a gtest assertion and returns an empty string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a2276ff84807d40b2fc4f7fd2ccc8b743" title="Returns the contents of a MINIDUMP_STRING as a string16. ">MinidumpStringAtRVAAsString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0e98915fad73c8628924c3a900732fc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* crashpad::test::MinidumpWritableAtLocationDescriptor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known. </p>
<p>This function has template specializations that perform more stringent checking than the default implementation:</p><ul>
<li>With a <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> template parameter, a template specialization ensures that the structure’s magic number and version fields are correct.</li>
<li>With a <a class="el" href="structMINIDUMP__MEMORY__LIST.html" title="Information about memory regions within the process. ">MINIDUMP_MEMORY_LIST</a>, <a class="el" href="structMINIDUMP__THREAD__LIST.html" title="Information about all threads within the process. ">MINIDUMP_THREAD_LIST</a>, <a class="el" href="structMINIDUMP__MODULE__LIST.html" title="Information about all modules loaded within the process at the time the snapshot was taken...">MINIDUMP_MODULE_LIST</a>, or MinidumpSimpleStringDictionary template parameter, template specializations ensure that the size given by <em>location</em> matches the size expected of a stream containing the number of elements it claims to have.</li>
<li>With an <a class="el" href="structIMAGE__DEBUG__MISC.html" title="Miscellaneous debugging record. ">IMAGE_DEBUG_MISC</a>, <a class="el" href="structcrashpad_1_1MinidumpModuleCodeViewRecordPDB20.html" title="A CodeView record linking to a .pdb 2.0 file. ">MinidumpModuleCodeViewRecordPDB20</a>, or <a class="el" href="structcrashpad_1_1MinidumpModuleCodeViewRecordPDB70.html" title="A CodeView record linking to a .pdb 7.0 file. ">MinidumpModuleCodeViewRecordPDB70</a> template parameter, template specializations ensure that the structure has the expected format including any magic number and the <code>NUL</code>-terminated string.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>A <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html" title="A pointer to a structure or union within a minidump file. ">MINIDUMP_LOCATION_DESCRIPTOR</a> giving the offset within the minidump file of the desired object, as well as its size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the size of <em>location</em> is at least as big as the size of the requested object, and if <em>location</em> is within the range of <em>file_contents</em>, returns a pointer into <em>file_contents</em> at offset <em>rva</em>. Otherwise, raises a gtest assertion failure and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a5b3e635fd21c8c642d41ceb2072e7d08" title="Returns a typed minidump object located within a minidump file’s contents, where the offset of the o...">MinidumpWritableAtRVA()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5cbb750966dcd4d580ba9eeb51a45fc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * crashpad::test::MinidumpWritableAtLocationDescriptorInternal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_oversized_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an untyped minidump object located within a minidump file’s contents, where the offset and size of the object are known. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>A <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html" title="A pointer to a structure or union within a minidump file. ">MINIDUMP_LOCATION_DESCRIPTOR</a> giving the offset within the minidump file of the desired object, as well as its size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_size</td><td>The expected size of the object. If <em>allow_oversized_data</em> is <code>true</code>, <em>expected_size</em> is treated as the minimum size of <em>location</em>, but it is permitted to be larger. If <em>allow_oversized_data</em> is <code>false</code>, the size of <em>location</em> must match <em>expected_size</em> exactly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_oversized_data</td><td>Controls whether <em>expected_size</em> is a minimum limit (<code>true</code>) or an exact match is required (<code>false</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the size of <em>location</em> is agrees with <em>expected_size</em>, and if <em>location</em> is within the range of <em>file_contents</em>, returns a pointer into <em>file_contents</em> at offset <em>rva</em>. Otherwise, raises a gtest assertion failure and returns <code>nullptr</code>.</dd></dl>
<p>Do not call this function. Use the typed version, <a class="el" href="namespacecrashpad_1_1test.html#a0e98915fad73c8628924c3a900732fc0" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a>, or another type-specific function. </p>

</div>
</div>
<a class="anchor" id="a5b3e635fd21c8c642d41ceb2072e7d08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* crashpad::test::MinidumpWritableAtRVA </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbghelp_8h.html#acf465a1a77ecf067a9d946583bc6a3f8">RVA</a>&#160;</td>
          <td class="paramname"><em>rva</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a typed minidump object located within a minidump file’s contents, where the offset of the object is known. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_contents</td><td>The contents of the minidump file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rva</td><td>The offset within the minidump file of the desired object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>rva</em> plus the size of an object of type <em>T</em> is within the range of <em>file_contents</em>, returns a pointer into <em>file_contents</em> at offset <em>rva</em>. Otherwise, raises a gtest assertion failure and returns <code>nullptr</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrashpad_1_1test.html#a0e98915fad73c8628924c3a900732fc0" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a35412b33d0a275fa43e8633296059534"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ReadStreamToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body. ">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream from which to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the stream, or an empty string on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a861ba97c72a60c7e1802c39395d1d1fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crashpad::test::ReadStreamToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrashpad_1_1HTTPBodyStream.html">HTTPBodyStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a <a class="el" href="classcrashpad_1_1HTTPBodyStream.html" title="An interface to a stream that can be used for an HTTP request body. ">HTTPBodyStream</a> to a string. If an error occurs, adds a test failure and returns an empty string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream from which to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>The size of the buffer to use when reading from the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the stream, or an empty string on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="abda65d4c6e9c710f32fcbd9af6a03357"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* crashpad::test::TMinidumpWritableAtLocationDescriptor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__LOCATION__DESCRIPTOR.html">MINIDUMP_LOCATION_DESCRIPTOR</a> &amp;&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a typed minidump object located within a minidump file’s contents, where the offset and size of the object are known. </p>
<p>This function is similar to <a class="el" href="namespacecrashpad_1_1test.html#a0e98915fad73c8628924c3a900732fc0" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a> and is used to implement that function. It exists independently so that template specializations are able to call this function, which provides the default implementation.</p>
<p>Do not call this function directly. Use <a class="el" href="namespacecrashpad_1_1test.html#a0e98915fad73c8628924c3a900732fc0" title="Returns a typed minidump object located within a minidump file’s contents, where the offset and size...">MinidumpWritableAtLocationDescriptor&lt;&gt;()</a> instead. </p>

</div>
</div>
<a class="anchor" id="a5e604ee6a23070a89e2a0015eb2854a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::test::VerifyMinidumpHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMINIDUMP__HEADER.html">MINIDUMP_HEADER</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies, via gtest assertions, that a <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> contains expected values. </p>
<p>All fields in the <a class="el" href="structMINIDUMP__HEADER.html" title="The top-level structure identifying a minidump file. ">MINIDUMP_HEADER</a> will be evaluated except for the Signature and Version fields, because those are checked by <a class="el" href="namespacecrashpad_1_1test.html#a68bb97f184e9e5a41356a960fdaf3320" title="Returns the MINIDUMP_HEADER at the start of a minidump file, along with the MINIDUMP_DIRECTORY it ref...">MinidumpHeaderAtStart()</a>. Most other fields are are compared to their correct default values. <a class="el" href="structMINIDUMP__HEADER.html#ac64203d27bba37f630437048a0e19630" title="The number of MINIDUMP_DIRECTORY elements present in the directory referenced by StreamDirectoryRva. ">MINIDUMP_HEADER::NumberOfStreams</a> is compared to <em>streams</em>, and <a class="el" href="structMINIDUMP__HEADER.html#a5f3811a143f2a6405e721d03d8c86f1d" title="The time that the minidump file was generated, in time_t format, the number of seconds since the POSI...">MINIDUMP_HEADER::TimeDateStamp</a> is compared to <em>timestamp</em>. Most fields are checked with nonfatal EXPECT-style assertions, but <a class="el" href="structMINIDUMP__HEADER.html#ac64203d27bba37f630437048a0e19630" title="The number of MINIDUMP_DIRECTORY elements present in the directory referenced by StreamDirectoryRva. ">MINIDUMP_HEADER::NumberOfStreams</a> and <a class="el" href="structMINIDUMP__HEADER.html#afc88b1f46827fbeae6ef6e0718a23b57" title="A pointer to an array of MINIDUMP_DIRECTORY structures that identify all of the streams within this m...">MINIDUMP_HEADER::StreamDirectoryRva</a> are checked with fatal ASSERT-style assertions, because they must be correct in order for processing of the minidump to continue. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
